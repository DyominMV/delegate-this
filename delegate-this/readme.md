# delegate-this

Наконец-то в котлине делегат интерфейса может использовать ссылку на делегатора!
> _вы ждали этого всю жизнь, я знаю_

## Введение

### Почему это плохо

Вообще-то во время создания делегата конструирование `this` ещё не завершено. Скорее всего именно из-за этого котлин 
изначально даже не даёт использовать `this` в выражении после слова `by`. Мало того, даже с таким великолепно безопасным
подходом, как в этом плагине, можно словить удивительные эффекты, если попытаться делегировать несколько интерфейсов 
нескольким разным делегатам, и для одного из них рассчитывать на корректную реализацию другого.

### Почему это хорошо

Вообще-то бывает полезно делегировать определённую логику по-разному в зависимости от состояния объекта. И если эта
логика описана довольно большим интерфейсом, то будет неприятно в каждом его методе писать однообразные ифы.

> _Использовать в таких целях прокси ещё хуже, чем разрешать получать ссылку на делегатора_

## Применение

### 1. Плагины

Просто так получить ссылку на делегатора не получится, сначала придётся добавить немного магии трансформации байткода.
Для этого реализованы плагины `delegate-this-(maven|gradle)-plugin`:

- мавен:
   ```xml
   <plugins>
       <plugin>
           <groupId>io.github.dyominmv</groupId>
           <artifactId>delegate-this-maven-plugin</artifactId>
           <version>${актуальная версия}</version>
           <executions>
               <execution>
                   <id>compile</id>
                   <phase>compile</phase>
                   <goals><goal>transform-delegators</goal></goals>
               </execution>
               <execution>
                   <id>test-compile</id>
                   <phase>test-compile</phase>
                   <goals><goal>transform-test-delegators</goal></goals>
               </execution>
           </executions>
       </plugin>
   </plugins>
   ```
- градле:
   ```kts
   plugins {
       id("io.github.dyominmv.delegate-this-gradle-plugin") version "актуальная версия"
   }
   ```

### 2. Зависимости

Если хотите получать ссылку на делегатора в своём делегате, то кроме подключения плагинов понадобится добавить 
зависимость на `delegate-this`.

- мавен:
   ```xml
   <dependency>
       <groupId>io.github.dyominmv</groupId>
       <artifactId>delegate-this</artifactId>
       <version>${актуальная версия}</version>
   </dependency>
   ```
- градле:
   ```kts
       implementation("io.github.dyominmv", "delegate-this", "актуальная версия")
   ```

### 3. Получаем ссылку на делегатора внутри делегата

Выражение, которым инициализируется делегат, должно возвращать реализацию интерфейса Delegate.
Например, так:

```kotlin
interface Animal {
    fun makeSound()
}

class Cat : Animal, Delegate {
    private lateinit var delegator: Any
    override fun receiveDelegator(delegator: Any) {
        this.delegator = delegator
    }

    override fun makeSound() = println("Meow, my hashCode is ${delegator.hashCode()}")
}

class AnimalDelegator: Animal by Cat()
```

## Как это работает?

Суть трансформации в следующем:
1. Среди только что скомпилированных class-файлов выискиваются те, у которых есть поля-наследники типа Delegate. Дальше 
имеем дело только с такими классами, у которых такие поля есть.
2. В класс добавляется приватный метод `delegate_this!()`, который каждому полю-делегату 
передаёт `this` (через вызов метода `receiveDelegator`)
3. Каждый конструктор класса делается приватным и в него добавляется пустой параметр-маркер (соответственно заменяются 
и вызовы этих конструкторов внутри изменённых конструкторов, _ну вы поняли_)
4. Возвращаются конструкторы с оригинальной сигнатурой, но внутри они сначала вызывают того своего изменённого клона, а 
затем смачно делают `delegate_this!()`

Всё это сделано, чтобы метод `receiveDelegator` был вызван только однажды сразу после логики конструирования объекта -
делегатора.

## Для чего это делалось в первую очередь

Чтобы можно было делегировать интерфейсы изменяемым свойствам! Проект [by-computed](../by-computed/readme.md) как раз 
про это.